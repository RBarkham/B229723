---
title: "B229723 - Programming Assignment"
output:
    rmdformats::material:
    toc_float: true
    code_folding: show
date: "2025-10-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(timeout = 600) # some data sets are on slower servers, so we have to give them more time to download
```

# Intro 
### Is there an association between antibiotic prescription rate, and cold weather? How does this vary by health board?

Antibiotics are one of the most widely prescribed class of medications, with (insert number) of people being prescribed them annually in the UK. Consequently, understanding the factors which influence prescription is paramount. This is especially important with the rise of antibiotic resistance, where over prescription promotes antibiotic resistance. 

In this report, we are looking at the prescription rate of antibiotics over 2 summer-winter periods, and seeing if there is any correlation between prescription rate in health boards, and the minimum average temperature. With cold weather promoting respiratory conditions, one of the main uses of antibiotics, we could expect to see an uptick of prescription during colder weather.

To investigate this, we will be using prescription data from NHS Scotland, population data from the UK government website (provided ultimately by the Scottish government), and temperature data from CEDA (originally provided by the MET office). We will start by using static graphs show preliminary findings. Secondly, an interactive web app to show temporal/spatial relationships in a dynamic manner



# Our Packages

```{R Package install, message=FALSE, warning=FALSE, result = FALSE}
packages = c(
  "tidyverse", "janitor", "sf", "terra", "exactextractr",
  "shiny", "here", "reactable", "rmdformats", "ggiraph", "scales", "manipulateWidget") # creates list of required packages

missing = packages[!packages %in% installed.packages()[, "Package"]]
if (length(missing) > 0) install.packages(missing) # checks to see if they are already installed, in not it will install missing packages

invisible(lapply(packages, library, character.only = TRUE)) #opens libarary of all packages
```


# Reading in Our Data
## Temp Data
First lets load our temperature data, we can't directly download our data from the CEDA website due to the login required (and the API which bypasses this is not yet functional)

To access the data, you can create a CEDA account and download the data and but it in your temperature data folder: *[ HadUK-grid 1km grid, v1.3.1.ceda](https://catalogue.ceda.ac.uk/uuid/f02cc6ddd92f45b18b9ab6ab544df7d9/)*
We'll be using data from the HadUK gridded data set, which provided a comprehensive overview of climate temperatures with high-resolution. From this data set, we can build a highly accurate record of average minium temperatures.
```{r Reading Temp Data, message=FALSE}
years <- c(2023, 2024) # we'll save this value, so we can rename our layers later easily using rep()

if (!dir.exists(here("Temperature_Data"))) {dir.create(here("Temperature_Data"))}

Temp_data_files =list.files(path = here("Temperature_Data"), pattern = "\\.nc$", full.names = TRUE)
Temp_data = lapply(Temp_data_files, rast)
all_Temp_data = c(Temp_data[[1]], Temp_data[[2]])

names(all_Temp_data) <- paste0(rep(years, each = 12), "_", month.name)
```

## Antibiotics Data
We can download our data directly from the Website at:  
*[Public Health Scotland, Prescriptions in the Community] (https://www.opendata.nhs.scot/dataset/prescriptions-in-the-community)*
We're going to use "paid_quantity" as our metric for antibiotics. Whilst it may seem initiative to use number_of_paid_items, there is a weakness that both multi-orders and single orders being counted as only 1 "number_of_paid_items. On the contrary, paid_quantity keeps a consistent count of medication volumes, so are more appropriate for our purposes
```{r Reading in Antibiotic data, message=FALSE}
# First you'll need a folder called "Antibiotics_Data", the script below will check and create one if its not present.
if(!dir.exists(here("Antibiotics_Data"))) {dir.create(here("Antibiotics_Data"))}
# Download the data from the link above. we'll be working with June-December in 2023 and 2024, in a .CSV format, once downloaded, put them into your antibiotics folder.

Antibiotics_data = list.files(path = here("Antibiotics_Data"), pattern = "\\.csv$", full.names = TRUE)
 
Data_List_Antibiotics = map(Antibiotics_data, ~ read_csv(.x) %>% 
                   clean_names() %>% 
                   select(hbt, bnf_item_code, paid_quantity, paid_date_month)%>%
                            filter(startsWith(
                              bnf_item_code, "05010"),
                              hbt != "SB0806"))
Data_Antibiotics = bind_rows(Data_List_Antibiotics)
 # First we will collate our data into a list, so we can process it all with one command, and add more data if required easily, here's the first couple, expand the code below to see the full thing.
```


## Population Data
In order to calculate Antibiotic doses per 1000, we'll need to divide our Antibiotic data by population

We'll be using population data from Public Health Scotland again, to provide population statistics. If you'd like to manually download the data, it can be found here:  
*[Public Health Scotland, Health Board (2019) Population Estimates](https://www.opendata.nhs.scot/dataset/population-estimates/resource/27a72cc8-d6d8-430c-8b4f-3109a9ceadb1)*
(Note, the website states population data is from 1981-2023, but actually stretches to 2024 too)

```{r Reading in Pop Data, message=FALSE}
 pop = read_csv("https://www.opendata.nhs.scot/dataset/7f010430-6ce1-4813-b25c-f7f335bdc4dc/resource/27a72cc8-d6d8-430c-8b4f-3109a9ceadb1/download/hb2019_pop_est_03102025.csv") %>% 
  clean_names()%>%
  filter(year %in% c("2023", "2024") &
           sex == "All" &
           hb != "S92000003") %>% 
  dplyr::select(hb, all_ages, year) #base R also has a select(). R can get confused to which select() you want to use, so adding dplyr:: before select() helps R pick the correct one (the dplyr version)
```

## Map data

We can download our map data from the Scottish Goverment website at:     *[spatialdata.gov.scot](https://www.spatialdata.gov.scot/geonetwork/srv/eng/catalog.search#/metadata/f12c3826-4b4b-40e6-bf4f-77b9ed01dc14)*
```{r Reading Map Data, message=FALSE}
 Scotland_Map = st_read("/vsizip/vsicurl/https://maps.gov.scot/ATOM/shapefiles/SG_NHS_HealthBoards_2019.zip/SG_NHS_HealthBoards_2019.shp", quiet = TRUE) %>% #/vsizip/vsicurl allows our data to open a zip file, and download it over the internet
  st_simplify( dTolerance = 1000) %>% #st_simplify makes our map data less data-intensive, and helps it run quicker
  st_transform( crs(all_Temp_data)) # st_transform makes sure that our map data will work with our temp data, this is because out temp data are data is organised differently (polygons or grids), this makes sure we can convert between the two easily.
```



# Data Wrangling and Joining
## Temperature Data
```{r .nc --> DF conversion, message=FALSE, results='hide'}
Temp_df = exact_extract(all_Temp_data, Scotland_Map, "mean",
                        full_colnames = FALSE, 
                        append_cols = "HBName") %>% 
                          select(-matches("(January|February|March|April|May)"))
#exact_extract adds "mean." to our column names. You can't prevent this, so we'll have to remove it so we can reliably process our data downstream.
names(Temp_df) = gsub("mean.", "", names(Temp_df)) 

Temp_df_Long = Temp_df %>%
  pivot_longer(
    cols = -c(HBName),   # we select the columns we want to turn into rows (all except HBName which we dont want to change)
    names_to = "Year_Month",     # new column name for month
    values_to = "Min_Temperature") %>%   # new column name for values
  separate("Year_Month", into = c("Year", "Month")) %>% # turning our single year_month column into seperate year and month columns
  mutate(Year = as.numeric(Year)) # we encode our year as a numeric, to ensure it can join other data later.
```

## Antibiotics Data
```{r Filtering and Extracting Date data, message=FALSE}
Antibiotics_data <- Data_Antibiotics %>%
        filter(startsWith(
          bnf_item_code, "05010"),
          hbt != "SB0806") %>%
        mutate(
          Year = as.numeric(substr(paid_date_month, 1, 4)),   # first 4 chars = year
          Month = month.name[as.numeric(substr(paid_date_month, 5, 6))]) # turn month into long form, for easy reading.
```

```{r Calculating Stats}
Tally_Antibiotics_Data = Antibiotics_data %>% 
  group_by(hbt,Year,Month) %>% 
  summarise(total_quanity = sum(paid_quantity, na.rm = TRUE), .groups = "keep")%>% 
  full_join(pop, by = join_by(hbt == hb, Year == year))
# full  join ensures we keep all the data in both data sets, even when there isn't a match. This means if there's incomplete sets, we can identify them by using anyNA(Tally_Antibiotics_Data) 

Antibiotics_dose_pc = Tally_Antibiotics_Data %>% 
  mutate(Dose_per_1000 = total_quanity/(all_ages/1000)) %>% 
  subset(select = -c(all_ages, total_quanity))
```

```{r Joining Antibiotic and Map Data, message=FALSE}
 Antibiotics_Temp_Map = Scotland_Map %>% 
  full_join(Antibiotics_dose_pc, join_by(HBCode == hbt))%>% 
             right_join(Temp_df_Long) %>% 
  relocate(c("Shape_Leng", "Shape_Area"), .before = geometry) # we will move our map data out of the way, so the data we want to review are together for improved readability
    
  Antibiotics_Temp_Table = Antibiotics_Temp_Map %>% 
    st_drop_geometry() %>% # we have to remove geometry data, reactable doesn't display data if it has geometry attached.
  select(-HBCode, -Shape_Leng, -Shape_Area) # removing excess/redundant information helps improve readability
```

# Tables of our data

```{r Antibiotics Data Table, message=FALSE}
 dropdown_filter = function(values, name) { #drop down provides filtering options for our data, once we put it into a table
  tags$select(
    onchange = sprintf(
      "Reactable.setFilter('antibiotics-table', '%s', event.target.value || undefined)", name),
    tags$option(value = "", "All"), 
    lapply(sort(unique(values)), tags$option),
    style = "width: 100%; height: 30px;")}

reactable( # we'll use teactable to make an interactive table
  Antibiotics_Temp_Table,
  filterable = TRUE,
  pagination = FALSE, # This lets us have a scroll bar rather than pages
  height = 400,
  defaultColDef = colDef(
    filterInput = dropdown_filter),
  columns = list(
    Dose_per_1000 = colDef(filterable = FALSE, 
                           name = "Doses per 1000"),
    Min_Temperature = colDef(filterable = FALSE,
                             name = "Minimum Temperature (ºC)"),
  elementId = "antibiotics-table"))

```
We can see that August is consistently the warmest month, accounting for 8/10 of the highest minimum temperatures. 2023 also saw higher mimimum temps, accounting for 8/10 of the highest minimum temperatures. The coldest 5 times where 7/10 of the 10 coldest months occurred in their Grampians, Tayside, or The Highlands. We see that Orkney has the lowest 4 month dosage rates. The western central belt saw the highest prescriptions rates with Lanarkshire and Ayrshire and Arran consistently saw high dosage rates, making up 6/10 of the highest dosage rates across both years. 


# Preliminary Graphs, and Looking for Associations
<div>
```{r Preliminary Graphs, message=FALSE}
                          
ggplot(Antibiotics_Temp_Table, aes(x = Min_Temperature, y = Dose_per_1000)) +
  geom_point(size = 1,
             color = "blue") +
  facet_wrap(~ Year) +
  geom_smooth(method = "lm",
              color = "red") +  # geom_smoth() ass a trend line, method = "lm" make it straight, 
  labs(x = "Minimum Temperature", y = " Antibiotic Doses per 1000", #data and graph labels
       title = "Scatter plot of Antibiotic Doses per 1000 vs Minimum Temperature") +
  theme_minimal() # formatting to it fits out page nicely
#pur <div> above, and </div> below this chunk, to prevent text overlap (outside of the ```).
```
</div>
From this graph, we can see there is a correlation between average minimum temperature, and the number of Antibiotic doses per 1000, as can be seen by our trend lines declining nature. However, we can't tell if different health boards are affected differently, and without the red trend line, it would be hard to see broarder trends. If we plot this on a map, we would be able to see spatial relationships, and be able to see temporal trends in greater resolution. By using chlorogrpahs, we will be able to see how regions compare, and weather there are areas with disproportinate perscriptions rates, when considering average minium temperatures.

# Interactive Maps
We'll use Shiny, and shiny. IO to make and host an app which will let us browse the full range of maps and identify any spatial-temporal trends in the data.
You can find the introduction to Shiny, and Shiny.IO below   
*[Shiny](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/)*
*[Shiny.IO](https://docs.posit.co/shinyapps.io/guide/index.html)*
<iframe 
src="https://rbarkham.shinyapps.io/antibiotics_map/"
data-external="1"
style="border: none"
width="100%" 
height="550px"
scrolling="no"
seamless = TRUE>
</iframe>

From the plots we can see an inverse relationship between antibiotics prescription and minimum temperature - as it gets warmer, less antibiotics are prescribed, we see that Tayside is consistently the coldest region (although not consistently the most prescribed). This cooperates with the correlation we observed in our first graph. However, Whilst we have observed a correlation, we do not have sufficient evidence to state there is a directly causal relationship. One important aspect to consider is the reported over caution my doctors in the winter months, and could artificially inflate antibiotic numbers, especially in areas with higher illness and elderly burdens. We have evidence which cooberates with this idea, with the top 10 highest dosage rate being reported to have the higest elderly population.

```{r}
if(!dir.exists(here("App_Data"))) {dir.create(here("App_Data"), recursive = TRUE)}
saveRDS(Antibiotics_Temp_Map, here("App_Data/Antibiotics_Temp_Map.rds"))
```

```{r eval=FALSE}
 # whilst it may seem intuitive to just download tidyverse, it is best to load individual packages separately. If we load tidyverse, we will download many packages which we don't need. When we're hosting on Shiny.IO servers, we have a limited amount of memory available to us, so the less packages the better.
library(shiny)
library(scales)
library(sf)
library(dplyr)
library(ggplot2)
library(ggiraph)
# If deploying/uploading, library(rsconnect) / install.packages(rsconnect)
#-------------------------------------------------------------------------------
Antibiotics_Temp_Map = readRDS(here("App_Data/Antibiotics_Temp_Map.rds"))
#remove here(App_Data/) when uploading to Shiny.IO
UI = fluidPage( # fluid page tells R that this is an interactive element
  style = "padding: 0; margin: 0;",
  titlePanel("Antibiotic Doses per 1000 by Health Board"),
  sidebarLayout( #the sidebar will be our filter drop down area
    sidebarPanel( width = 3, style = "padding: 0; margin: 0;",
      selectInput("Year", "Select Year",  # 1st drop down box,for year
                  choices = c(2023, 2024)), #options for drop down box
      selectInput("Month", "Select Month", # 2nd drop down box, for month
                  choices = month.name[6:12])) ,# options for drop down box
 mainPanel(
      splitLayout(
        cellWidths = c("50%", "50%"), # splits the row 50/50
        cellArgs = list(style = "padding: 0;"), #removes padding
        girafeOutput("Min_Temp_Map", height = "100%", width = "100%"),
        girafeOutput("Antibiotic_Map", height = "100%", width = "100%")
      )))) # tells R which plots we want to display (we define what they are in the server section)

Server = function(input, output, session) {
  
Filter = reactive({ # reactive tells R that it needs to update everytime a new selection is made
    Antibiotics_Temp_Map %>%
      filter(Year == input$Year, #tells R that it has to filter based on the input of the drop downs.
             Month == input$Month)})
  
output$Antibiotic_Map = renderGirafe({
    Antibiotics_Data = Filter() #Filtered() acts as a placeholder for our filtered data
    ggplot_Antibiotics = ggplot(Antibiotics_Data) +
  geom_sf_interactive(
        aes(fill = Dose_per_1000,
            tooltip = paste0("HB :", HBName, "<br>",
                             "Dose per 1000: ", round(Dose_per_1000, 2)),
            data_id = HBName),
            color = "white") + # we'll make the outline of the map white 
  scale_fill_gradient(
        low = "#F5E3FA",
        high = "#A50026",
        limits = c(1200, 3200), # we set a uniform limit to all data, we we can compare month by month easily
        labels = label_comma()) +
  labs(
        title = paste("Antibiotic Doses per 1000 —",input$Month, input$Year),
        subtitle = "By Scottish Health Boards",
        fill = "Dose Per 1000") +
  guides(fill = guide_colorbar(
        barwidth = 10,   # width of the legend bar
        barheight = 1)) +
  theme_minimal() +
  theme(legend.position = "bottom", # move legend to the bottom to prevent ambiguity 
            plot.margin = margin(50, 0, 0, 0)) 
    
  girafe(ggobj = ggplot_Antibiotics,
           width_svg = 5,   # internal width in inches
           height_svg = 7)
  })

output$Min_Temp_Map = renderGirafe({
    Min_Temp = Filter()
    ggplot_Temp = ggplot(data = Min_Temp) +
  geom_sf_interactive(aes(fill = Min_Temperature, 
                            tooltip = paste0("HB :", HBName,"<br>", 
                                        "Min temp :", round(Min_Temperature, 2)), 
                                         data_id = HBName),
                            color = "white") +
  scale_fill_gradient2(
      low = "#313695",
      mid = "#F5E3FA",
      high = "#A50026",
      midpoint = 5.5,
      limits = c(-0.75, 11.75),
      labels = label_number()) +
  labs(
      title = paste("Minimum Temperature —", input$Month, input$Year),
      subtitle = "By Scottish Health Boards",
      fill = "Minimum Temperature (ºC)") +
  guides(fill = guide_colorbar(
      barwidth = 10,
      barheight = 1)) +
  theme_minimal() +
  theme(legend.position = "bottom",
            plot.margin = margin(50, 0, 0, 0))
  girafe(ggobj = ggplot_Temp,
         width_svg = 5,   # internal width in inches
         height_svg = 7) 
})}
shinyApp(UI, Server) # tells R to run the app

#when you want to upload your app to Shiny IO, you need to use rsconnect, to link you account and computer, when you create your account you'll be given a token to enter into R
#You do not need to add it to your app as you will only use it to upload the app. You can see the intro linked above for details.

# Copy and paste this, outside of the chunk on its own (not in a chunk)
# <iframe 
# src="[link given when deploying app" 
# data-external="1"
# style="border: none"
# width="100%" 
# height="700px"
# scrolling="no"
# seamless = TRUE>
# </iframe>
```

# Next steps:
This give us a meaningful insight into the trends which affect antibiotic prescription. With these findings, healthcare providers could use weather forecasts to help predict parthenogenesis in the community, and prepare for seasonal demand efficiently. By scouring Antibiotics more efficiently, healthcare providers can save money by preventing over-ordering and disposing of unused expired medications. 

This is not the only issues faced by seasonal prescriptions, as mentioned previously, over-perscription can promote antibiotic resistance. Future studies should also look at the bacterial:non-bacterial infection rate and compare it with the antibiotic doses per 1000 data. In regions where antibiotics are incorrectly prescribed, we would be able to spot that bacterial:non-bacterial infection rates are low with a disproportionatley high Antibiotic dosage per 1000 rate and could provide significant public benefits by helping curb antibiotic resistance development.
